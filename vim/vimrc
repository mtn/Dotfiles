" Dein {
    call plug#begin('~/.vim/plugged')

      " Plugins, etc.:
      Plug 'scrooloose/nerdtree'
      Plug 'Xuyuanp/nerdtree-git-plugin'
      Plug 'tpope/vim-commentary'
      Plug 'tpope/vim-fugitive'
      Plug 'tpope/vim-surround'
      Plug 'tpope/vim-abolish'
      Plug 'w0rp/ale'
      " Plug 'Valloric/YouCompleteMe', {'build': './install.py'}
      Plug 'vim-scripts/restore_view.vim'
      Plug 'mhinz/vim-signify'
      Plug 'vim-airline/vim-airline'
      Plug 'vim-airline/vim-airline-themes'
      Plug 'jiangmiao/auto-pairs'
      Plug 'dhruvasagar/vim-table-mode'
      Plug 'AlessandroYorba/Alduin'

      Plug 'rust-lang/rust.vim'

      call plug#end()

    filetype plugin indent on
    syntax enable
" }

scriptencoding utf-8
set shell=$SHELL
set background=dark
set mousehide
set showmode

set cursorline
set colorcolumn=90
set number
set relativenumber
set linespace=0
set smarttab
set showmatch

set hlsearch
set incsearch                   " Find as you type search
nnoremap <silent> <Enter> :nohlsearch<Bar>:echo<CR>
noremap ; :
noremap ;; ;


set virtualedit=onemore
set iskeyword-=.
set iskeyword-=#
set iskeyword-=-

set hidden
set history=10000
set backspace=indent,eol,start
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set infercase
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set foldenable
set list

if has('mac')
    set wildignorecase
endif

set listchars=trail:•,tab:›\ ,extends:#,nbsp:. " Whitespace, etc.
if has('clipboard')
    if has('unnamedplus')  " When possible use + register for copy-paste
        set clipboard=unnamed,unnamedplus
    else         " On mac and Windows, use * register for copy-paste
        set clipboard=unnamed
    endif
endif

au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

set shiftwidth=4
set expandtab
set tabstop=4
set softtabstop=4
set nojoinspaces
set autoindent
set nospell

let mapleader = ','

nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap <leader>j <C-W><C-J>
nnoremap <leader>k <C-W><C-K>
nnoremap <leader>l <C-W><C-L>
nnoremap <leader>h <C-W><C-H>

nnoremap <leader>v <C-V>

nnoremap <leader>d :bp<cr>
nnoremap <leader>f :bn<cr>

" let g:ycm_show_diagnostics_ui = 0
" autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2
autocmd FileType latex,tex,md,markdown,txt,text setlocal spell

set splitright
set splitbelow

" Dynamically resize active window
" set winwidth=104
" set winheight=5
" set winminheight=5
" set winheight=999


" Alduin {
    let g:alduin_Contract_Vampirism = 1
    color alduin
" }

highlight clear SignColumn      " SignColumn should match background

if has('cmdline_info')
    set ruler                   " Show the ruler
    set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
    set showcmd                 " Show partial commands in status line and
endif

if has('statusline')
    set laststatus=2
    set statusline=%<%f\                     " Filename
    set statusline+=%w%h%m%r                 " Options
    set statusline+=%{fugitive#statusline()} " Git Hotness
    set statusline+=\ [%{&ff}/%Y]            " Filetype
    set statusline+=\ [%{getcwd()}]          " Current dir
    set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
endif

if has('gui_running')
    set guifont=Meslo\ LG\ S\ DZ\ Regular\ for\ Powerline:h13
endif

" Trailing Whitespace {
    function TrimSpaces()
      if !&binary && &filetype != 'diff'
        normal mz
        normal Hmy
        %s/\s\+$//e
        normal 'yz<CR>
        normal `z
      endif
    endfunction

    command! -bar -nargs=0 TrimSpaces <line1>,<line2>call TrimSpaces()
" }

" NerdTree {
"     if isdirectory(expand("~/.vim/plugged/nerdtree"))
"       noremap <C-e> :NERDTreeToggle<CR>
"       noremap <leader>e :NERDTreeToggle<CR>

"       let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
"       let NERDTreeShowHidden=1
"       let NERDTreeQuitOnOpen=1
"       let NERDTreeShowBookmarks=1
"     endif
" }

" vim-airline {
    if isdirectory(expand("~/.vim/plugged/vim-airline/"))
      if isdirectory(expand("~/.vim/plugged/vim-airline-themes/"))
        if !exists('g:airline_theme')
          let g:airline_theme = 'alduin'
        endif
      endif
      let g:airline_powerline_fonts = 1
      let g:airline#extensions#tabline#enabled = 1
      let g:airline#extensions#ale#enabled = 1
    endif
"  }

" ale {
    let g:ale_lint_on_enter = 1
    noremap <leader>r :ALENextWrap<CR>
    noremap <leader>t :ALEPreviousWrap<CR>
" }

" Persistent Undo {
    let vimDir = '$HOME/.vim'
    let &runtimepath.=','.vimDir

    " Keep undo history across sessions by storing it in a file
    if has('persistent_undo')
        let undoDir = expand(vimDir . '/undodir')
        " Create dirs
        call system('mkdir ' . vimDir)
        call system('mkdir ' . undoDir)
        let &undodir = undoDir
        set undofile
    endif
" }

